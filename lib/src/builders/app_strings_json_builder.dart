import 'dart:io';

import 'package:analyzer/dart/element/element.dart';
import 'package:app_strings/app_strings.dart';
import 'package:app_strings/src/generators/app_strings_json_generator.dart';
import 'package:app_strings/src/models/field_tree.dart';
import 'package:build/build.dart';
import 'package:path/path.dart' as p;
import 'package:source_gen/source_gen.dart';

// region [p]

class AppStringsJsonBuilder extends GeneratorForAnnotation<AppStringsConfig> {
  @override
  generateForAnnotatedElement(Element element, ConstantReader annotation, BuildStep buildStep) async {
    ///* Remove the locale file
    var locale = annotation.peek("remove")?.stringValue;
    if (locale != null) {
      var jsonFilePath = p.setExtension(p.withoutExtension(buildStep.inputId.path), ".$locale.json");
      var file = File(jsonFilePath);
      if (file.existsSync()) {
        file.delete();
      }
    }

    ///* Build the FieldTree from the source file
    var sourceTree = await FieldTree.fromAst(buildStep);
    if (sourceTree == null) {
      return null;
    }

    ///* Generate the json files
    var file = File(buildStep.inputId.path);
    var jsonGenerator = AppStringsJsonGenerator(
      fieldTree: sourceTree,
      root: file.parent.path,
      prefix: buildStep.inputId.pathSegments.last.split('.').first,
    );
    var files = jsonGenerator.build();

    ///* Check if the jsonExport annotation is true
    var exportJson = annotation.read("json").boolValue;
    if (exportJson == false) {
      ///* Write the generated json files
      files.forEach((filePath, fileContent) {
        final file = File(filePath);
        file.delete();
      });

      return null;
    }

    await Future.forEach(files.keys, (filePath) async {
      var sourceFile = File(filePath);
      final fileContent = files[filePath];

      if (fileContent != null) {
        await sourceFile.writeAsString(fileContent);
      }
    });

    return '''

// This file is automatically created and regenerated by the 'app_strings:json_builder'.
// Its primary purpose is to ensure the **localization JSON files** // are regenerated whenever the build runner is executed.
//
// The value below is a simple timestamp/hash and is necessary to override 
// the build runner's internal caching mechanism.
//
// If you need to force a full regeneration of the JSON files, 
// run: dart run build_runner build --delete-conflicting-outputs
//
// Last forced update marker:
// ${DateTime.now().microsecondsSinceEpoch}

''';
  }
}

// endregion
